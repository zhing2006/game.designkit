---
description: 识别游戏规范中未明确的领域，通过最多5个高度针对性的澄清问题并将答案编码回规范
---

## 用户输入

```text
$ARGUMENTS
```

必须考虑用户输入（如果非空）。

## 概述

目标：检测并减少当前游戏规范中的模糊性或缺失的决策点，并将澄清结果直接记录到规范文件中。

注意：此澄清工作流预期在调用 `/game.designkit.plan` 之前运行（并完成）。如果用户明确表示跳过澄清（例如探索性尖峰），您可以继续，但必须警告下游返工风险增加。

执行步骤：

1. 从仓库根目录运行
  Windows: `.game.design/scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly`
  Linux or MacOS: `.game.design/scripts/bash/check-prerequisites.sh --json --paths-only`
**一次**。解析 JSON 字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - `SPEC_TYPE`
   - （可选：捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程）
   - 如果 JSON 解析失败，中止并指示用户重新运行 `/game.designkit.specify` 或验证功能分支环境。
   - 对于包含单引号的参数（如 "I'm Groot"），使用转义语法：'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）。
   - **解析 SPEC_TYPE 字段**：用于确定规范类型（global 或 feature）。

2. 读取设计支柱（如果存在 `.game.design/memory/pillars.md`），用于后续的支柱一致性检查。如果文件不存在，记录警告但继续执行基础澄清流程。

3. 加载当前规范文件。

   **根据 SPEC_TYPE 调整澄清粒度**：
   - **global spec（全局型规范）**：重点关注体验目标、核心循环完整性、概念关系、风格一致性等定性内容，避免具体数值参数（如容量、数量、百分比）和系统实现细节
   - **feature spec（功能型规范）**：可以深入到具体数值、数据模型、状态转换、UI/UX 流程等实现层面

   使用以下分类法执行结构化的模糊性和覆盖率扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖地图（除非不会提出问题，否则不要输出原始地图）。

   功能范围与行为（所有规范类型）：
   - 核心玩家目标和体验目标
   - 明确的范围外声明
   - 玩家角色/类型区分

   游戏实体与关系（概念层面适用于所有类型，详细规则主要用于 feature spec）：
   - 实体、属性、关系（角色、道具、系统等）
   - 实体唯一性规则
   - 状态转换和生命周期
   - 数量/规模假设

   玩家交互流程（高层旅程适用于所有类型，详细流程主要用于 feature spec）：
   - 关键玩家旅程/操作序列
   - 错误/空状态/加载状态
   - UI/UX 反馈

   边缘情况与失败处理（主要用于 feature spec）：
   - 负面场景（失败、异常）
   - 冲突解决（例如资源竞争）

   设计约束与权衡（所有规范类型）：
   - 设计约束（例如"必须单人"、"必须回合制"）
   - 明确的权衡或拒绝的替代方案

   术语与一致性（所有规范类型）：
   - 规范术语表
   - 避免的同义词

   验收标准（所有规范类型）：
   - 验收标准可测试性
   - 可衡量的完成指标

   占位符检查（所有规范类型）：
   - TODO 标记/未解决的决策
   - 模糊形容词缺乏量化

   游戏设计对齐（所有规范类型）：
   - 与设计支柱的一致性（如果 pillars.md 存在）
   - 与既定设计原则的语义冲突

   游戏愿景对齐（仅 feature spec）：
   - 与 game-vision（000-game-vision）体验目标的对齐
   - 对情感曲线的贡献（紧张/放松/高潮阶段）
   - 在核心玩法循环中的位置（输入/过程/奖励/反馈）

   对于状态为 Partial 或 Missing 的每个类别，添加候选问题机会，除非：
   - 澄清不会实质性改变实施或验证策略
   - 信息更适合推迟到规划阶段（内部注明）

4. 生成（内部）优先级排序的候选澄清问题队列（最多 5 个）。不要一次输出所有问题。应用以下约束：
    - 整个会话最多总共 10 个问题。
    - 每个问题必须可以用以下任一方式回答：
       - 简短的多项选择（2-5 个不同的、互斥的选项），或
       - 单词/短语答案（明确限制："回答不超过 5 个字"）。
    - 仅包含答案会实质性影响架构、数据建模、任务分解、测试设计、UX 行为、运营就绪或合规验证的问题。
    - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如安全态势）未解决时询问两个低影响问题。
    - 排除已回答的问题、琐碎的风格偏好或计划级执行细节（除非阻碍正确性）。
    - 优先考虑减少下游返工风险或防止验收测试不对齐的澄清。
    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。
    - **SPEC_TYPE 特定约束**：
      - 如果 SPEC_TYPE == "global"：避免询问具体数值（除非该数值是核心体验承诺的一部分）。优先澄清体验目标、关系动态、风格一致性等定性内容。
      - 如果 SPEC_TYPE == "feature"：可以询问具体数值、数据结构、状态转换等实现细节。

5. 顺序提问循环（交互式）：
    - 每次恰好提出一个问题。
    - 对于多项选择题：
       - **分析所有选项**并根据以下标准确定**最合适的选项**：
          - 项目类型的最佳实践
          - 类似实现中的常见模式
          - 风险降低（安全性、性能、可维护性）
          - 与规范中可见的任何明确项目目标或约束的对齐
       - 在顶部突出显示您**推荐的选项**，并提供清晰的理由（用 1-2 句话解释为什么这是最佳选择）。
       - 格式为：`**推荐：** 选项 [X] - <理由>`
       - 然后将所有选项呈现为 Markdown 表格：

       | 选项 | 描述 |
       |------|------|
       | A | <选项 A 描述> |
       | B | <选项 B 描述> |
       | C | <选项 C 描述>（根据需要添加 D/E，最多 5 个） |
       | 简答 | 提供不同的简短答案（<=5 个字）（仅在适合自由形式替代时包含） |

       - 在表格后添加：`您可以回复选项字母（例如"A"），通过说"yes"或"推荐"接受推荐，或提供您自己的简短答案。`
    - 对于简答题（没有有意义的离散选项）：
       - 根据最佳实践和上下文提供您的**建议答案**。
       - 格式为：`**建议：** <您提议的答案> - <简要理由>`
       - 然后输出：`格式：简短答案（<=5 个字）。您可以通过说"yes"或"建议"接受建议，或提供您自己的答案。`
    - 在用户回答后：
       - 如果用户回复"yes"、"推荐"或"建议"，使用您之前陈述的推荐/建议作为答案。
       - 否则，验证答案映射到一个选项或符合 <=5 字约束。
       - 如果模糊，请求快速消歧（计数仍属于同一问题；不要推进）。
       - 一旦满意，将其记录在工作内存中（尚未写入磁盘）并移至下一个排队的问题。
    - 在以下情况停止提问：
       - 所有关键模糊性已提前解决（剩余排队项目变得不必要），或
       - 用户发出完成信号（"done"、"good"、"no more"），或
       - 您达到 5 个已提问的问题。
    - 永远不要提前透露未来排队的问题。
    - 如果开始时没有有效问题，立即报告无关键模糊性。

6. 每个接受的答案后的集成（增量更新方法）：
    - 维护规范的内存表示（在开始时加载一次）以及原始文件内容。
    - 对于本次会话中的第一个集成答案：
       - 确保存在 `## Clarifications` 章节（如果缺失，根据规范模板在最高级别的上下文/概述章节之后创建它）。
       - 在其下，为今天创建（如果不存在）`### Session YYYY-MM-DD` 子标题。
    - 在接受后立即追加一个要点行：`- Q: <问题> → A: <最终答案>`。
    - 然后立即将澄清应用于最合适的章节：
       - 功能模糊性 → 在功能需求中更新或添加要点。
       - 用户交互/角色区分 → 使用澄清的角色、约束或场景更新用户故事或角色小节（如果存在）。
       - 数据形状/实体 → 更新数据模型（添加字段、类型、关系）保留顺序；简洁地注明添加的约束。
       - 非功能约束 → 在非功能/质量属性章节中添加/修改可衡量标准（将模糊形容词转换为指标或明确目标）。
       - 边缘情况/负面流程 → 在边缘情况/错误处理下添加新要点（或如果模板提供占位符则创建此小节）。
       - 术语冲突 → 规范化整个规范中的术语；仅在必要时保留原始术语，通过添加`（以前称为"X"）`一次。
    - 如果澄清使先前的模糊陈述无效，替换该陈述而不是重复；不留过时的矛盾文本。
    - 在每次集成后保存规范文件以最小化上下文丢失的风险（原子覆盖）。
    - 保留格式：不要重新排序无关章节；保持标题层次结构完整。
    - 保持每个插入的澄清最小且可测试（避免叙述漂移）。

7. 验证（在每次写入后执行加最终验证）：
   - Clarifications 会话每个接受的答案恰好包含一个要点（无重复）。
   - 总共提问（接受）的问题 ≤ 5。
   - 更新的章节不包含新答案本应解决的遗留模糊占位符。
   - 没有矛盾的早期陈述残留（扫描已删除的现在无效的替代选择）。
   - Markdown 结构有效；仅允许新标题：`## Clarifications`、`### Session YYYY-MM-DD`。
   - 术语一致性：所有更新的章节中使用相同的规范术语。

8. 将更新后的规范写回 `FEATURE_SPEC`。

9. 报告完成情况（提问循环结束或提前终止后）：
   - 提问和回答的问题数量。
   - 更新后的规范路径。
   - 触及的章节（列出名称）。
   - 覆盖摘要表，列出每个分类类别的状态：Resolved（曾是 Partial/Missing 并已处理）、Deferred（超出问题配额或更适合规划阶段）、Clear（已足够）、Outstanding（仍然 Partial/Missing 但影响较低）。
   - 如果有任何 Outstanding 或 Deferred 残留，建议是否继续执行 `/game.designkit.plan` 或稍后在 plan 后再次运行 `/game.designkit.clarify`。
   - 建议的下一个命令。

行为规则：

- **根据 SPEC_TYPE 调整粒度**：对于 global spec，保持高层次的体验导向问题；对于 feature spec，深入到可执行的实现细节。
- 如果未发现有意义的模糊性（或所有潜在问题影响都很低），回复："未检测到值得正式澄清的关键模糊点"并建议继续。
- 如果规范文件缺失，指示用户先运行 `/game.designkit.specify`（不要在此处创建新规范）。
- 永远不要超过总共 5 个已提问的问题（单个问题的澄清重试不计入新问题）。
- 避免推测性的技术栈问题，除非缺失会阻碍功能清晰度。
- 尊重用户提前终止信号（"stop"、"done"、"proceed"）。
- 如果由于完全覆盖而未提问，输出紧凑的覆盖摘要（所有类别清晰），然后建议推进。
- 如果达到配额但仍有未解决的高影响类别，在 Deferred 下明确标记它们并说明理由。

优先级排序的上下文：$ARGUMENTS
